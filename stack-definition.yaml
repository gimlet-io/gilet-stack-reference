---
name: Bootstrap curated Kubernetes stacks!
description: |
  Logging, metrics, ingress and more - all delivered with gitops.

categories:
  - name: "‚òÅÔ∏è Cloud Provider"
    id: cloud
  - name: "‚¨ÖÔ∏èIngress"
    id: ingress
  - name: "üìë Logging"
    id: logging
  - name: "üî¢ Metrics"
    id: metrics
  - name: "üîê Secrets"
    id: secrets
  - name: "üîç Tracing"
    id: tracing
  - name: "üìã Policy"
    id: policy
  - name: "‚öôÔ∏è Gimlet"
    id: gimlet
  - name: "üñ•Ô∏è System"
    id: system
components:
  - name: K3s / K3d / Rancher Desktop
    variable: k3s
    category: cloud
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/k3s.svg
    description: 'Enable k3s defaults to better integrate with locally running K3s, K3d and Rancher Desktop'
    onePager: |-
      Enable k3s defaults to better integrate with locally running K3s, K3d and Rancher Desktop
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#k3s",
        "type": "object",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "usingBuiltInTraefikIngress": {
            "$id": "#/properties/usingBuiltInTraefikIngress",
            "type": "boolean",
            "title": "Use the Traefik Ingress",
            "default": true
          }
        },
        "dependencies": {
          "usingBuiltInTraefikIngress": {
            "oneOf": [
              {
                "properties": {
                  "usingBuiltInTraefikIngress": {
                    "const": false
                  }
                }
              },
              {
                "properties": {
                  "usingBuiltInTraefikIngress": {
                    "const": true
                  },
                  "host": {
                    "$id": "#/properties/host",
                    "type": "string",
                    "title": "Host",
                    "description": "Your company domain you will expose your services on"
                  }
                },
                "required": [
                  "host"
                ]
              }
            ]
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#k3s"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: CIVO
    variable: civo
    category: cloud
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/civo.svg
    description: 'Enable CIVO Cloud defaults to better integrate into the CIVO landscape'
    onePager: |-
      Enable CIVO Cloud defaults to better integrate into the CIVO landscape
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#civo",
        "type": "object",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "usingBuiltInTraefikIngress": {
            "$id": "#/properties/usingBuiltInTraefikIngress",
            "type": "boolean",
            "title": "Use the Traefik Ingress from the CIVO marketplace"
          }
        },
        "dependencies": {
          "usingBuiltInTraefikIngress": {
            "oneOf": [
              {
                "properties": {
                  "usingBuiltInTraefikIngress": {
                    "const": false
                  }
                }
              },
              {
                "properties": {
                  "usingBuiltInTraefikIngress": {
                    "const": true
                  },
                  "host": {
                    "$id": "#/properties/host",
                    "type": "string",
                    "title": "Host",
                    "description": "Your company domain you will expose your services on"
                  }
                },
                "required": [
                  "host"
                ]
              }
            ]
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#civo"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: Nginx
    variable: nginx
    category: ingress
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/nginx.png
    description: 'An Nginx proxy server that routes traffic to your applications based on the host name or path.'
    onePager: |-
      ### What do you get with Nginx?

      An Nginx proxy server that routes traffic to your applications based on the host name or path.

      ### How to verify the deployment?

      ```
      $ kubectl get pods,services --namespace infrastructure
      NAME                                                   READY   STATUS    RESTARTS   AGE
      nginx-nginx-ingress-default-backend-6d96c457f6-hfkn8   1/1     Running   0          114s
      nginx-nginx-ingress-controller-6874d7c7f-l7dzc         1/1     Running   0          114s

      NAME                                          TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE
      service/nginx-nginx-ingress-controller        LoadBalancer   10.43.199.76    1.2.3.4       80:30377/TCP,443:31126/TCP   114s
      service/nginx-nginx-ingress-default-backend   ClusterIP      10.43.176.181   <none>        80/TCP                       114s
      ```

      It started the ingress controller pod and the default-backend pod that is served on HTTP 404 requests.

      ### Pointing a DNS entry to the ingress IP address

      Locate the external IP of the `nginx-nginx-ingress-controller` service. On local clusters this will always be `Pending`, but on managed Kubernetes providers, the IP is set within a couple of minutes.

      You need to create now DNS entry for this IP. A wildcard DNS on `*.yourdomain.com` is preferred for this purpose.

      To validate the ingress, let's use nip.io, which is a dynamic DNS service: it provides wildcard DNS for any IP address. Say your LAN IP address is 10.0.0.1.
      Using nip.io, 10.0.0.1.nip.io resolves to 10.0.0.1

      Now try [https://test.<<yourIP>>.nip.io](https://test.<<yourIP>>.nip.io) which will return HTTP 404, served by the just deployed default backend. Indicating that the ingress controller works.

      Next steps:
      - add a wildcard DNS entry that points to the `nginx-nginx-ingress-controller` service's IP
      - add a [Kubernetes ingress](https://kubernetes.io/docs/concepts/services-networking/ingress/) object to one of your applications.
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#nginx",
        "type": "object",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled",
            "default": false
          }
        },
        "dependencies": {
          "enabled": {
            "oneOf": [
              {
                "properties": {
                  "enabled": {
                    "const": false
                  }
                }
              },
              {
                "properties": {
                  "enabled": {
                    "const": true
                  },
                  "host": {
                    "$id": "#/properties/host",
                    "type": "string",
                    "title": "Host",
                    "description": "Your company domain you will expose your services on"
                  }
                },
                "required": [
                  "host"
                ]
              }
            ]
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#nginx"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: CertManager
    variable: certManager
    category: ingress
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/certManager.png
    description: ''
    onePager: |-
      ### What do you get with Cert Manager?

      Free SSL certificates for all your applications from Let's Encrypt

      ### How to verify the deployment?

      ```
      $ kubectl get pods,clusterissuer --namespace infrastructure
      NAME                                                   READY   STATUS    RESTARTS   AGE
      cert-manager-cainjector-5c88c48f9-pxc6p                1/1     Running   0          5m2s
      cert-manager-75d94494d6-7zzg4                          1/1     Running   0          5m2s
      cert-manager-webhook-864997b596-jfdpz                  1/1     Running   0          5m2s

      NAME                                        READY   AGE
      clusterissuer.cert-manager.io/letsencrypt   True    1m
      ```

      Once the `ClusterIssuer` is created, Cert Manager is ready to issue Let's Encrypt certificates for your ingresses. It takes about 5 minutes to set it up.

      If you enabled Grafana Loki or Prometheus, then you have already a Kubernetes Ingress that utilizes the certificates:

      ```
      kubectl get ingress -n infrastructure
      NAME      HOSTS                       ADDRESS           PORTS     AGE
      grafana   grafana.test.laszlo.cloud   172.104.145.220   80, 443   13h
      ```

      It binds under the `grafana` subdomain of the host that you set for Nginx, and has the `cert-manager.io/cluster-issuer` annotation that connects the Ingress with the ClusterIssuer,
      indicating that Cert Manager should provision a certificate.

      ```
      kubectl get ingress grafana -n infrastructure

      apiVersion: extensions/v1beta1
      kind: Ingress
      metadata:
        annotations:
          cert-manager.io/cluster-issuer: letsencrypt
          helm.fluxcd.io/antecedent: infrastructure:helmrelease/grafana
          kubernetes.io/ingress.class: nginx
        name: grafana
        namespace: infrastructure
      spec:
        rules:
        - host: grafana.test.laszlo.cloud
          http:
            paths:
            - backend:
                serviceName: grafana
                servicePort: 80
              path: /
        tls:
        - hosts:
          - grafana.test.laszlo.cloud
          secretName: tls-grafana
      ```
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#certManager",
        "type": "object",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          }
        },
        "dependencies": {
          "enabled": {
            "oneOf": [
              {
                "properties": {
                  "enabled": {
                    "const": false
                  }
                }
              },
              {
                "properties": {
                  "enabled": {
                    "const": true
                  },
                  "email": {
                    "$id": "#/properties/email",
                    "type": "string",
                    "title": "Administrator email",
                    "description": "Let's Encrypt will email you on this email upon expiring certificates"
                  }
                },
                "required": [
                  "email"
                ]
              }
            ]
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#certManager"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: Loki
    variable: loki
    category: logging
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/loki.png
    description: ''
    onePager: |-
      ### What do you get with Loki?

      - All your logs are forwarded to a dashboard
      - Flexible querying. See applications log realtime, or search for errors across all your apps
      - Log based alerts

      ### How to verify the deployment?
      ```
      $ kubectl get pods --namespace infrastructure

      NAME                         READY   STATUS    RESTARTS   AGE
      grafana-5dc6466b8d-2xkwf     1/1     Running   0          47h
      loki-promtail-bvn87          1/1     Running   0          32m
      loki-0                       1/1     Running   0          32m
      ```

      ### Logging in to Grafana

      Forward the internal ClusterIP to your laptop with:
      ```
      kubectl port-forward svc/grafana --namespace infrastructure 8888:80
      ```

      and access the dashboard on [http://localhost:8888](http://localhost:8888).

      Grafana generates an `admin` user password, and puts it into a Kubernetes secret. Grab it with:

      ```
      kubectl get secret grafana --namespace infrastructure --template='{{ index .data "admin-password"}}' | base64 -d
      ```

      Make sure to not include the trailing new line character: `%`

      On [http://localhost:8888/explore](http://localhost:8888/explore) start exploring the application logs by selecting the Loki datasource.
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "http://example.com/example.json",
        "type": "object",
        "title": "The root schema",
        "description": "The root schema comprises the entire JSON document.",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "storage": {
            "$id": "#/properties/storage",
            "type": "object",
            "title": "Storage",
            "oneOf": [
              {
                "id": "#/properties/storage/oneOf/0",
                "title": "Volume Storage",
                "properties": {
                  "retentionDays": {
                    "type": "integer",
                    "title": "Retentian (in days)",
                    "minimum": 1
                  }
                },
                "required": ["retentionDays"]
              },
              {
                "id": "#/properties/storage/oneOf/1",
                "title": "S3 Storage",
                "type": "object",
                "properties": {
                  "s3Url": {
                    "type": "string",
                    "title": "S3 URL",
                    "description": "The name of the volume. Used only to recognize the volumes purpose in the config later on",
                    "default": "s3://<access_key>:<uri-encoded-secret-access-key>@<region>"
                  },
                  "bucketName": {
                    "type": "string",
                    "title": "Bucket Name",
                    "description": "Use an existing PersistentVolumeClaim",
                    "default": "my-bucket"
                  }
                },
                "required": [
                  "s3Url",
                  "bucketName"
                ]
              }
            ]
          },
          "persistence": {
            "$id": "#/properties/persistence",
            "type": "boolean",
            "title": "Persistence"
          },
          "volumeSize": {
            "$id": "#/properties/volumeSize",
            "type": "integer",
            "title": "Peristent Volume Size (in GB)",
            "default": 10,
            "minimum": 1
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#/properties/enabled",
            "#/properties/storage",
            "#/properties/persistence",
            "#/properties/volumeSize"
          ],
          "uiSchema": {
          },
          "metaData": {}
        }
      ]
  - name: Grafana Cloud
    variable: grafanaCloud
    category: logging
    logo: https://grafana.com/static/img/menu/grafana2.svg
    description: ''
    onePager: |-
      Install Promtail to ship logs to Grafana Cloud.
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#grafanaCloud",
        "type": "object",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "clusterName": {
            "$id": "#/properties/clusterName",
            "type": "string",
            "title": "Cluster Name",
            "description": "A unique cluster identifier that is attached to labels shipped by this Prometheus. You can use this later on for querying."
          },
          "url": {
            "$id": "#/properties/url",
            "type": "string",
            "title": "URL",
            "description": "URL field on the Grafana Cloud dashboard"
          },
          "username": {
            "$id": "#/properties/username",
            "type": "string",
            "title": "User",
            "description": "User field on the Grafana Cloud dashboard"
          },
          "password": {
            "$id": "#/properties/password",
            "type": "string",
            "title": "Password / API Key",
            "description": "Password field on the Grafana Cloud dashboard"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#grafanaCloud"
          ],
          "uiSchema": {
          },
          "metaData": {}
        }
      ]
  - name: Event Exporter
    variable: eventExporter
    category: logging
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/opsgenie.png
    description: ''
    onePager: |-
      Install Kubernetes Event Exporter to log all Kubernetes events.
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#eventExporter",
        "type": "object",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#eventExporter"
          ],
          "uiSchema": {
          },
          "metaData": {}
        }
      ]
  - name: Prometheus
    variable: prometheus
    category: metrics
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/prometheus.svg
    description: ''
    onePager: |-
      ### What do you get with Prometheus?
      - Infrastructure metrics and dashboards
      - Integration to application metrics
      - Default alerts and dashboards

      ### How to verify the deployment?

      ```
      $ kubectl get pods,svc --namespace infrastructure | grep 'prometheus\|grafana'

      NAME                                                   READY   STATUS    RESTARTS   AGE
      grafana-6987c9c5cf-gsr6x                               1/1     Running   0          66s
      prometheus-kube-state-metrics-c65b87574-qw56j          1/1     Running   0          65s
      prometheus-node-exporter-z8hgt                         1/1     Running   0          65s
      prometheus-pushgateway-7dc7cd5748-zzcc9                1/1     Running   0          65s
      prometheus-alertmanager-78b946d89-8djl8                1/2     Running   0          65s
      prometheus-server-b65c9b875-j62n8                      1/2     Running   0          65s
      service/grafana                               ClusterIP      10.43.64.217    <none>        80/TCP
      service/prometheus-alertmanager               ClusterIP      10.43.154.189   <none>        80/TCP
      service/prometheus-kube-state-metrics         ClusterIP      10.43.66.232    <none>        8080/TCP
      service/prometheus-server                     ClusterIP      10.43.133.254   <none>        80/TCP
      service/prometheus-node-exporter              ClusterIP      None            <none>        9100/TCP
      service/prometheus-pushgateway                ClusterIP      10.43.77.103    <none>        9091/TCP
      ```

      ### Browsing metrics with Grafana
      You can access the dashboards by forwarding the internal Grafana ClusterIP to your laptop with:
      ```
      kubectl port-forward svc/grafana --namespace infrastructure 8888:80
      ```

      and access the dashboard on [http://localhost:8888](http://localhost:8888).

      Grafana generates an `admin` user password, and puts it into a Kubernetes secret. Grab it with:

      ```
      kubectl get secret grafana --namespace infrastructure --template='{{ index .data "admin-password"}}' | base64 -d
      ```

      Make sure to not include the trailing new line character: `%`

    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#prometheus",
        "type": "object",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "retentionDays": {
            "$id": "#/properties/retentionDays",
            "type": "integer",
            "title": "Retentian (in days)",
            "default": 14,
            "minimum": 1,
            "maximum": 365
          },
          "persistence": {
            "$id": "#/properties/persistence",
            "type": "boolean",
            "title": "Persistence"
          },
          "volumeSize": {
            "$id": "#/properties/volumeSize",
            "type": "integer",
            "title": "Peristent Volume Size (in GB)",
            "default": 10,
            "minimum": 1,
            "maximum": 100
          },
          "grafanaCloud": {
            "$id": "#/properties/grafanaCloud",
            "type": "object",
            "title": "Write to Grafana Cloud",
            "properties": {
              "enabled": {
                "$id": "#/properties/enabled",
                "type": "boolean",
                "title": "Enabled"
              },
              "clusterName": {
                "$id": "#/properties/clusterName",
                "type": "string",
                "title": "Cluster Name",
                "description": "A unique cluster identifier that is attached to labels shipped by this Prometheus. You can use this later on for querying."
              },
              "url": {
                "$id": "#/properties/url",
                "type": "string",
                "title": "Remote Write Endpoint",
                "description": "Remote Write Endpoint URL on the Grafana Cloud dashboard"
              },
              "username": {
                "$id": "#/properties/username",
                "type": "string",
                "title": "Username / Instance ID",
                "description": "Username / Instance ID on the Grafana Cloud dashboard"
              },
              "password": {
                "$id": "#/properties/password",
                "type": "string",
                "title": "Password / API Key",
                "description": "Password / API Key on the Grafana Cloud dashboard"
              }
            }
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#prometheus"
          ],
          "uiSchema": {
            "#/properties/retentionDays": {
              "ui:widget": "range"
            },
            "#/properties/volumeSize": {
              "ui:widget": "range"
            }
          },
          "metaData": {}
        }
      ]
  - name: Sealed Secrets
    variable: sealedSecrets
    category: secrets
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/sealedSecrets.svg
    description: ''
    onePager: |-
      ### What do you get with Sealed Secrets?
      - A secret manager that allows a simple secret workflow for gitops repositories.
      - Uses asymmetric cryptography to encrypt secrets, just like HTTPS.
      ### How to verify the deployment?

      ```
      $ kubectl get pods --namespace infrastructure

      NAME                              READY   STATUS    RESTARTS   AGE
      sealed-secrets-7d7cc48f7f-q64sm   1/1     Running   0          14m
      ```

      Once the pod is running, secrets will be unsealed inside the cluster and made available for your applications.

      ### After verification

      In order to encrypt secrets, run the following steps:

      #### Install the `kubeseal` utility

      You will use this utility to encrypt secrets for your applications. It uses asymmetric crypto to encrypt secrets that only the controller can decrypt.

      Mac:
      ```
      brew install kubeseal
      ```

      Linux:
      ```
      wget https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.12.6/kubeseal-linux-amd64 -O kubeseal
      sudo install -m 755 kubeseal /usr/local/bin/kubeseal
      ```

      #### Important steps after installing Sealed Secrets

      Perform these steps if you install Sealed Secrets for the first time, and you don't have encrypted secrets in your gitops repo yet.

      - fetch the sealing key

      ```
      kubeseal --fetch-cert --controller-namespace=infrastructure > sealing-key.pub
      ```

      This key is used to encrypt your secrets. It is only used to encrypt the secrets, noone can decrypt the secrets with this key, so you can share it with anyone.

      It is recommended that you add this key as a "Sealing Public Key" to 1-Click Infra bellow, so all keys in the gitops repo will be encrypted.

      - backup the master key

      ```
      kubectl get secret -n infrastructure -l sealedsecrets.bitnami.com/sealed-secrets-key -o yaml > master.key
      ```

      Keep this key secret, as this is the only key that can decrypt the secrets.
      Use it only in case of a cluster restoration.

      **Steps after restoration**

      Perform these steps if you are restoring your cluster, and you have encrypted secrets in your gitops repo already.

      Locate your backed up master key and apply it on the cluster.

      ```
      kubectl apply -f master.key
      ```

      Then restart the Sealed Secrets to pick up the master key:

      ```
      kubectl -n infrastructure delete pod -l name=sealed-secrets-controller
      ```

      Now your cluster can decrypt all secrets from the gitops repo.

    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "http://example.com/example.json",
        "type": "object",
        "title": "The root schema",
        "description": "The root schema comprises the entire JSON document.",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#/properties/enabled"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: ExternalSecrets
    variable: externalSecrets
    category: secrets
    logo: https://raw.githubusercontent.com/external-secrets/external-secrets/main/assets/eso-logo-medium.png
    description: ''
    onePager: |-
      The project extends the Kubernetes API by adding an ExternalSecrets object using Custom Resource Definition and a controller to implement the behavior of the object itself.

      An ExternalSecret declares how to fetch the secret data, while the controller converts all ExternalSecrets to Secrets. The conversion is completely transparent to Pods that can access Secrets normally.

      - `ExternalSecrets` are added in the cluster (e.g., kubectl apply -f external-secret-example.yml)
      - Controller fetches `ExternalSecrets` using the Kubernetes API
      - Controller uses `ExternalSecrets` to fetch secret data from external providers (e.g, AWS Secrets Manager)
      - Controller upserts `Secrets`
      - Pods can access `Secrets` normally
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "http://example.com/example.json",
        "type": "object",
        "title": "The root schema",
        "description": "The root schema comprises the entire JSON document.",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#/properties/enabled"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: Grafana Tempo
    variable: tempo
    category: tracing
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/tempo.png
    description: ''
    onePager: |-
      ### What do you get with Tempo?
      - Grafana Tempo is an open source, easy-to-use and high-volume distributed tracing backend. Tempo is cost-efficient, requiring only object storage to operate, and is deeply integrated with Grafana, Prometheus, and Loki.

      ### How to verify the deployment?

      ```
      $ kubectl get pods --namespace infrastructure | grep tempo

      NAME                              READY   STATUS    RESTARTS   AGE
      tempo-0  1/1     Running   0          1m
      ```


    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "http://example.com/example.json",
        "type": "object",
        "title": "The root schema",
        "description": "The root schema comprises the entire JSON document.",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
           "sampleTraceData": {
            "$id": "#/properties/sampleTraceData",
            "type": "boolean",
            "title": "Sample Trace Data"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#/properties/enabled",
            "#/properties/sampleTraceData"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: Kyverno
    variable: kyverno
    category: policy
    logo: https://raw.githubusercontent.com/kyverno/kyverno/main/img/logo.png
    description: ''
    onePager: |-
      ### What do you get with Kyverno?
      - Kyverno is a policy engine designed for Kubernetes. It can validate, mutate, and generate configurations using admission controls and background scans. Kyverno policies are Kubernetes resources and do not require learning a new language. Kyverno is designed to work nicely with tools you already use like kubectl, kustomize, and Git.

      ### How to verify the deployment?

      ```
      $ kubectl get pods --namespace infrastructure | grep kyverno

      NAME                              READY   STATUS    RESTARTS   AGE
      kyverno-5ccd8d64b4-5vqlk  1/1     Running   0          1m
      ```

      ### Validate the deployed policies

      ```
      kubectl get policyreport -A
      kubectl get clusterpolicyreport
      ```

      ### Check policy reports

      kubectl describe polr polr-ns-staging -n staging | grep "Result: \+fail" -B10

      or in Grafana on the "Poilicy Reports" dashboard

    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "http://example.com/example.json",
        "type": "object",
        "title": "The root schema",
        "description": "The root schema comprises the entire JSON document.",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "podSecurityStandard": {
            "$id": "#/properties/podSecurityStandard",
            "type": "string",
            "title": "Security Standard",
            "enum": [
              "baseline",
              "restricted"
            ],
            "default": "baseline"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#/properties/enabled",
            "#/properties/podSecurityStandard"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: OAuth2Proxy
    variable: oauth2Proxy
    category: ingress
    logo: https://raw.githubusercontent.com/oauth2-proxy/oauth2-proxy/master/docs/static/img/logos/OAuth2_Proxy_icon.svg
    description: ''
    onePager: |-
      ### What do you get with OAuth2Proxy?
      - You can authenticate your internal services with Github
      - Use it instead of a VPN

      ### How to verify the deployment?

      ```
      kubectl get pods --namespace infrastructure
      ```
      ```
      NAME                                                   READY   STATUS    RESTARTS   AGE
      oauth2-proxy-56cc5665c5-t6472                          2/2     Running   2          18h
      ```

      ### Configuring the Github OAuth app

      Follow the [Github guide](https://docs.github.com/en/developers/apps/building-oauth-apps/creating-an-oauth-app).

      - Set `https://auth.<<your-nginx-domain>>` for "Homepage URL"
      - Set `https://auth.<<your-nginx-domain>>/oauth2/callback` for "Authorization callback URL"

      ### Add OAuth to your service
      To add authentication for your services, add the following annotations to your ingresses:
      ```diff
      apiVersion: extensions/v1beta1
      kind: Ingress
      metadata:
        name: my-app
        namespace: infrastructure
        annotations:
          kubernetes.io/ingress.class: 'nginx'
      +   nginx.ingress.kubernetes.io/auth-url: "https://auth.<<your-nginx-domain>>/oauth2/auth"
      +   nginx.ingress.kubernetes.io/auth-signin: "https://auth.<<your-nginx-domain>>/oauth2/start?rd=/redirect/$http_host$escaped_request_uri"
      spec:
        tls:
        - hosts:
          - my-app.<<your-nginx-domain>>
        rules:
          - host: my-app.<<your-nginx-domain>>
            http:
              paths:
                - backend:
                    serviceName: my-app
                    servicePort: 80
      ```

      ### Checking if you are logged in

      Visit [https://auth.<<your-nginx-domain>>/oauth2/userinfo](https://auth.<<your-nginx-domain>>/oauth2/userinfo)
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#oauth2Proxy",
        "type": "object",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "cookieSecret": {
            "$id": "#/properties/cookieSecret",
            "type": "string",
            "title": "Cookie Secret",
            "description": "A random seed string that is the base of cookie encryption. eg: the output of `openssl rand -hex 16`"
          },
          "org": {
            "$id": "#/properties/org",
            "type": "string",
            "title": "Github Organization",
            "description": "Github users member of this organization will be allowed to access your protected sites"
          },
          "user": {
            "$id": "#/properties/user",
            "type": "string",
            "title": "Github User",
            "description": "If you want to grant access per user basis, a comma separated list"
          },
          "clientID": {
            "$id": "#/properties/clientID",
            "type": "string",
            "title": "Github ClientID",
            "description": "ClientID of the Github OAuth application"
          },
          "clientSecret": {
            "$id": "#/properties/clientSecret",
            "type": "string",
            "title": "Github Client Secret",
            "description": "Client secret of the Github OAuth application"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#oauth2Proxy"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: Gimlet Dashboard
    variable: gimletDashboard
    category: gimlet
    logo: https://gimlet.io/logo.svg
    description: ''
    onePager: |-

    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#gimletDashboard",
        "type": "object",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "host": {
            "$id": "#/properties/host",
            "type": "string",
            "title": "Host name",
            "description": "The hostname the dashboard is accessible. Together with the protocol eg.: https://gimlet.mycompany.com"
          },
          "jwtSecret": {
            "$id": "#/properties/jwtSecret",
            "type": "string",
            "title": "JWT Secret",
            "description": "Random string to seed JWT tokens, eg the output of `openssl rand -hex 32`"
          },
          "githubOrg": {
            "$id": "#/properties/githubOrg",
            "type": "string",
            "title": "Github Organization",
            "description": "Users that are members of this Github Organization will be able to authenticate to the dashboard"
          },
          "gimletdToken": {
            "$id": "#/properties/githubOrg",
            "type": "string",
            "title": "GimletD Token",
            "description": "A GimletD admin token"
          },
          "githubAppId": {
            "$id": "#/properties/githubAppId",
            "type": "string",
            "title": "Github App ID",
            "description": ""
          },
          "githubPrivateKey": {
            "$id": "#/properties/githubPrivateKey",
            "type": "string",
            "title": "Github Private Key",
            "description": ""
          },
          "githubClientId": {
            "$id": "#/properties/githubClientId",
            "type": "string",
            "title": "Github Client ID",
            "description": ""
          },
          "githubClientSecret": {
            "$id": "#/properties/githubClientSecret",
            "type": "string",
            "title": "Github Client Secret",
            "description": ""
          },
          "webhookSecret": {
            "$id": "#/properties/webhookSecret",
            "type": "string",
            "title": "Webhook Secret",
            "description": ""
          },
          "postgresql": {
            "$id": "#/properties/postgresql",
            "type": "object",
            "title": "Postgresql settings",
            "description": "",
            "properties": {
              "install": {
                "$id": "#/properties/install",
                "type": "boolean",
                "title": "Install Postgresql",
                "description": "Install a Postgresql instance to host Gimlet data"
              },
              "postgresPassword": {
                "$id": "#/properties/postgresPassword",
                "type": "string",
                "title": "Postgresql Admin Password",
                "description": "Fill it if you install Postgresql together with Gimlet"
              },
              "hostAndPort": {
                "$id": "#/properties/hostAndPort",
                "type": "string",
                "title": "Postgresql Host and Port",
                "description": "If you install a postgresql together with Gimlet, then it is `postgres:5432`",
                "default": "postgres:5432"
              },
              "db": {
                "$id": "#/properties/database",
                "type": "string",
                "title": "Postgresql Database Name",
                "default": "gimlet_dasboard"
              },
              "user": {
                "$id": "#/properties/user",
                "type": "string",
                "title": "Postgresql User",
                "description": "",
                "default": "gimlet_dashboard"
              },
              "password": {
                "$id": "#/properties/password",
                "type": "string",
                "title": "Postgresql Password",
                "description": ""
              }
            }
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#gimletDashboard"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: Gimlet Agent
    variable: gimletAgent
    category: gimlet
    logo: https://gimlet.io/logo.svg
    description: ''
    onePager: |-

    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#gimletAgent",
        "type": "object",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "environment": {
            "$id": "#/properties/environment",
            "type": "string",
            "title": "Environment",
            "description": "The logical name of the environment the agent is deployed to"
          },
          "dashboardAddress": {
            "$id": "#/properties/dashboardAddress",
            "type": "string",
            "title": "Gimlet Dashboard Address",
            "description": "The address where Gimlet Dashboard is running, eg.: https://gimlet.mycompany.com"
          },
          "agentKey": {
            "$id": "#/properties/agentKey",
            "type": "string",
            "title": "Agent Key",
            "description": "Agent Key to authenticate to Gimlet Dashboard"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#gimletAgent"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: Gimletd
    variable: gimletd
    category: gimlet
    logo: https://gimlet.io/logo.svg
    description: ''
    onePager: |-

    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#gimletd",
        "type": "object",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "environments": {
            "$id": "#/properties/environments",
            "type": "array",
            "title": "Environments",
            "default": [],
            "additionalItems": true,
            "items": {
              "$id": "#/properties/environments/items",
              "type": "object",
              "properties": {
                "name": {
                  "$id": "#/properties/environments/items/properties/name",
                  "type": "string",
                  "title": "Environment Name",
                  "description": "The name of the environment. Should match with the `env` field in Gimlet manifests"
                },
                "repoPerEnv": {
                  "$id": "#/properties/environments/items/repoPerEnv",
                  "type": "boolean",
                  "title": "Use a dedicated gitops repo for this environment",
                  "description": "Whether this env has its dedicated git repository, or uses a shared one",
                  "default": true
                },
                "gitopsRepo": {
                  "$id": "#/properties/environments/items/gitopsRepo",
                  "type": "string",
                  "title": "Gitops Repository",
                  "description": "Repository owner and name (owner/name) where Gimletd writes the application manifests for this environment"
                },
                "deployKey": {
                  "$id": "#/properties/environments/items/deployKey",
                  "type": "string",
                  "title": "Deploy Key",
                  "description": "The private key of the deploy key pair to access the gitops repo for this environment"
                }
              }
            }
          },
          "postgresql": {
            "$id": "#/properties/postgresql",
            "type": "object",
            "title": "Postgresql settings",
            "description": "",
            "properties": {
              "install": {
                "$id": "#/properties/install",
                "type": "boolean",
                "title": "Install Postgresql",
                "description": "Install a Postgresql instance to host Gimlet data"
              },
              "postgresPassword": {
                "$id": "#/properties/postgresPassword",
                "type": "string",
                "title": "Postgresql Admin Password",
                "description": "Fill it if you install Postgresql together with Gimlet"
              },
              "hostAndPort": {
                "$id": "#/properties/hostAndPort",
                "type": "string",
                "title": "Postgresql Host and Port",
                "description": "If you install a postgresql together with Gimlet, then it is `postgres:5432`",
                "default": "postgres:5432"
              },
              "db": {
                "$id": "#/properties/database",
                "type": "string",
                "title": "Postgresql Database Name",
                "default": "gimletd"
              },
              "user": {
                "$id": "#/properties/user",
                "type": "string",
                "title": "Postgresql User",
                "description": "",
                "default": "gimletd"
              },
              "password": {
                "$id": "#/properties/password",
                "type": "string",
                "title": "Postgresql Password",
                "description": ""
              }
            }
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#gimletd"
          ],
          "uiSchema": {
            "#gimletd": {
              "deployKey": {
                "ui:widget": "textarea",
                "ui:options": {
                  "rows": 8
                }
              },
              "environments": {
                "items": {
                  "deployKey": {
                    "ui:widget": "textarea",
                    "ui:options": {
                      "rows": 8
                    }
                  }
                }
              }
            }
          },
          "metaData": {}
        }
      ]
  - name: Namespaces
    variable: namespaces
    category: system
    logo: 'https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/system.svg'
    description: ''
    onePager: |-

    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "namespaces",
        "type": "object",
        "default": {},
        "properties": {
          "namespaces": {
            "$id": "#/properties/namespaces",
            "type": "array",
            "title": "Namespaces",
            "default": [],
            "additionalItems": true,
            "items": {
              "$id": "#/properties/namespaces/items",
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "$id": "#/properties/namespaces/items/properties/name",
                  "type": "string",
                  "title": "Namespace"
                }
              }
            }
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "namespaces"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]

changeLog: |
  - üçè Gimlet manifest optimizations
  - üçè Cert Manager to 1.9.1
  - üçè External Secrets to 0.5.9
  - üçè Grafana from 9.0.2 to 9.1.5
  - üçè Ingress Nginx to 1.3.0
  Minimum Kubernetes version: Kubernetes v1.19.0
  Adds support for Kubernetes v1.24.0
  - üçè Kyverno from 1.7.1 to 1.7.3
  - üçè Loki from 2.5.0 to 2.6.1
  - üçè Prometheus from 2.34.0 to 2.36.2
  - üçè SealedSecrets from 0.18.0 to 0.18.2

message: |

  Hey üëã Laszlo here, the maker of Gimlet.

  Thank you for using Gimlet!

  My goal is to help you

  - to get started with your Kubernetes stack
  - to navigate new versions
  - and to give you best practices

  Now that you generated Kubernetes resources from your stack, 
  maybe you are interested in how to manage it in the future
  
  üëâ https://gimlet.io/docs/managing-infrastructure-components

  Onwards!
