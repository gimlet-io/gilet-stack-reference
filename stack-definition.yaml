---
name: Bootstrap curated Kubernetes stacks!
description: |
  Logging, metrics, ingress and more - all delivered with gitops.

categories:
  - name: "Container Registry"
    id: registry
  - name: "Ingress"
    id: ingress
  - name: "Logging"
    id: logging
  - name: "Metrics"
    id: metrics
  - name: "Secrets"
    id: secrets
  - name: "Autoscaling"
    id: autoscaling
  - name: "Gimlet"
    id: gimlet
components:
  - name: Nginx
    variable: nginx
    category: ingress
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/nginx.png
    description: "An Nginx proxy server that routes traffic to your applications based on the host name or path."
    onePager: |-
      ### What do you get with Nginx?

      An Nginx proxy server that routes traffic to your applications based on the host name or path.

      ### How to verify the deployment?

      ```
      $ kubectl get pods,services --namespace infrastructure
      NAME                                                   READY   STATUS    RESTARTS   AGE
      nginx-nginx-ingress-default-backend-6d96c457f6-hfkn8   1/1     Running   0          114s
      nginx-nginx-ingress-controller-6874d7c7f-l7dzc         1/1     Running   0          114s

      NAME                                          TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE
      service/nginx-nginx-ingress-controller        LoadBalancer   10.43.199.76    1.2.3.4       80:30377/TCP,443:31126/TCP   114s
      service/nginx-nginx-ingress-default-backend   ClusterIP      10.43.176.181   <none>        80/TCP                       114s
      ```

      ### Pointing a DNS entry to the ingress IP address

      To point a DNS entry to the ingress controller's IP address, let's find the IP first.
            
      ```
      $ kubectl get services --namespace infrastructure

      NAME                                          TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE
      service/nginx-nginx-ingress-controller        LoadBalancer   10.43.199.76    1.2.3.4       80:30377/TCP,443:31126/TCP   114s
      ```

      **Using a real Kubernetes cluster** the EXTERNAL-IP field is set within a couple of minutes by your cloud provider.

      Once the EXTERNAL-IP is visible, point a wildcard DNS entry `*.yourdomain.com` to that address.

      **Using a local Kubernetes cluster like k3s/k3d or Rancher / Docker Desktop / Minikube / kind** testing the ingress requires a few steps.

      First, port forward the nginx controller to your laptop with the `kubectl port-forward -n infrastructure svc/ingress-nginx-controller 8080:80` command.
      This will make the ingress controller reachable on the `127.0.0.1` address. However ingresses require DNS names, so we will use the nip.io dynamic DNS service for it.

      Using nip.io
      - 10.0.0.1.nip.io resolves to 10.0.0.1
      - similarly 127.0.0.1.nip.io will resolve to 127.0.0.1
      - even wildcard names work: xyz.1.2.3.4.nip.io resolves to 1.2.3.4

      Let's create a dummy ingress now that points to a non-existing app in the cluster, and use the nip.io based DNS name:

      ```
      kubectl create ingress dummy-ingress --rule="nosuchapp.127.0.0.1.nip.io/*=nosuchapp:80"
      ```

      Accessing [http://nosuchapp.127.0.0.1.nip.io](http://nosuchapp.127.0.0.1.nip.io) will return HTTP 404, served by the just deployed Nginx ingress controller. Indicating that the ingress controller works.
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#nginx",
        "type": "object",
        "title": "Nginx",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled",
            "default": false
          }
        },
        "dependencies": {
          "enabled": {
            "oneOf": [
              {
                "properties": {
                  "enabled": {
                    "const": false
                  }
                }
              },
              {
                "properties": {
                  "enabled": {
                    "const": true
                  },
                  "host": {
                    "$id": "#/properties/host",
                    "type": "string",
                    "title": "Host",
                    "description": "Your company domain you will expose your services on"
                  }
                },
                "required": [
                  "host"
                ]
              }
            ]
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#nginx"
          ],
          "uiSchema": {},
          "metaData": {
            "link": {
              "label": "DNS",
              "href": "https://gimlet-documentation-home-page-revamp.gimlet.io/docs/deployment-settings/dns"
            }
          }
        }
      ]
  - name: cert-manager
    variable: certManager
    category: ingress
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/certManager.png
    description: ""
    onePager: |-
      ### What do you get with Cert Manager?

      Free SSL certificates for all your applications from Let's Encrypt

      ### How to verify the deployment?

      ```
      $ kubectl get pods,clusterissuer --namespace infrastructure
      NAME                                                   READY   STATUS    RESTARTS   AGE
      cert-manager-cainjector-5c88c48f9-pxc6p                1/1     Running   0          5m2s
      cert-manager-75d94494d6-7zzg4                          1/1     Running   0          5m2s
      cert-manager-webhook-864997b596-jfdpz                  1/1     Running   0          5m2s

      NAME                                        READY   AGE
      clusterissuer.cert-manager.io/letsencrypt   True    1m
      ```

      Once the `ClusterIssuer` is created, Cert Manager is ready to issue Let's Encrypt certificates for your ingresses. It takes about 5 minutes to set it up.

      If you enabled Grafana Loki or Prometheus, then you have already a Kubernetes Ingress that utilizes the certificates:

      ```
      kubectl get ingress -n infrastructure
      NAME      HOSTS                       ADDRESS           PORTS     AGE
      grafana   grafana.test.laszlo.cloud   172.104.145.220   80, 443   13h
      ```

      It binds under the `grafana` subdomain of the host that you set for Nginx, and has the `cert-manager.io/cluster-issuer` annotation that connects the Ingress with the ClusterIssuer,
      indicating that Cert Manager should provision a certificate.

      ```
      kubectl get ingress grafana -n infrastructure

      apiVersion: extensions/v1beta1
      kind: Ingress
      metadata:
        annotations:
          cert-manager.io/cluster-issuer: letsencrypt
          helm.fluxcd.io/antecedent: infrastructure:helmrelease/grafana
          kubernetes.io/ingress.class: nginx
        name: grafana
        namespace: infrastructure
      spec:
        rules:
        - host: grafana.test.laszlo.cloud
          http:
            paths:
            - backend:
                serviceName: grafana
                servicePort: 80
              path: /
        tls:
        - hosts:
          - grafana.test.laszlo.cloud
          secretName: tls-grafana
      ```
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#certManager",
        "type": "object",
        "title": "cert-manager",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          }
        },
        "dependencies": {
          "enabled": {
            "oneOf": [
              {
                "properties": {
                  "enabled": {
                    "const": false
                  }
                }
              },
              {
                "properties": {
                  "enabled": {
                    "const": true
                  },
                  "email": {
                    "$id": "#/properties/email",
                    "type": "string",
                    "title": "Administrator email",
                    "description": "Let's Encrypt will email you on this email upon expiring certificates"
                  }
                },
                "required": [
                  "email"
                ]
              }
            ]
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#certManager"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: Existing Ingress
    variable: existingIngress
    category: ingress
    logo: ""
    description: ""
    onePager: ""
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#existingIngress",
        "type": "object",
        "title": "Existing Ingress",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "ingressAnnotations": {
            "$id": "#/properties/ingressAnnotations",
            "type": "string",
            "title": "Ingress Annotations"
          },
          "host": {
            "$id": "#/properties/host",
            "type": "string",
            "title": "Host",
            "description": "Your domain you will expose your services on"
          }
        },
        "dependencies": {}
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#existingIngress"
          ],
          "uiSchema": {
            "#/properties/ingressAnnotations": {
              "ui:widget": "textarea"
            }
          },
          "metaData": {}
        }
      ]
  - name: Loki
    variable: loki
    category: logging
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/loki.png
    description: ""
    onePager: |-
      ### What do you get with Loki?

      - All your logs are forwarded to a dashboard
      - Flexible querying. See applications log realtime, or search for errors across all your apps
      - Log based alerts

      ### How to verify the deployment?
      ```
      $ kubectl get pods --namespace infrastructure

      NAME                         READY   STATUS    RESTARTS   AGE
      grafana-5dc6466b8d-2xkwf     1/1     Running   0          47h
      loki-promtail-bvn87          1/1     Running   0          32m
      loki-0                       1/1     Running   0          32m
      ```

      ### Logging in to Grafana

      Forward the internal ClusterIP to your laptop with:
      ```
      kubectl port-forward svc/grafana --namespace infrastructure 8888:80
      ```

      and access the dashboard on [http://localhost:8888](http://localhost:8888).

      Grafana generates an `admin` user password, and puts it into a Kubernetes secret. Grab it with:

      ```
      kubectl get secret grafana --namespace infrastructure --template='{{ index .data "admin-password"}}' | base64 -d
      ```

      Make sure to not include the trailing new line character: `%`

      On [http://localhost:8888/explore](http://localhost:8888/explore) start exploring the application logs by selecting the Loki datasource.
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "http://example.com/example.json",
        "type": "object",
        "title": "Loki",
        "description": "The root schema comprises the entire JSON document.",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "storage": {
            "$id": "#/properties/storage",
            "type": "object",
            "title": "Storage",
            "oneOf": [
              {
                "id": "#/properties/storage/oneOf/0",
                "title": "Volume Storage",
                "properties": {
                  "retentionDays": {
                    "type": "integer",
                    "title": "Retentian (in days)",
                    "minimum": 1
                  }
                },
                "required": ["retentionDays"]
              },
              {
                "id": "#/properties/storage/oneOf/1",
                "title": "S3 Storage",
                "type": "object",
                "properties": {
                  "s3Url": {
                    "type": "string",
                    "title": "S3 URL",
                    "description": "The name of the volume. Used only to recognize the volumes purpose in the config later on",
                    "default": "s3://<access_key>:<uri-encoded-secret-access-key>@<region>"
                  },
                  "bucketName": {
                    "type": "string",
                    "title": "Bucket Name",
                    "description": "Use an existing PersistentVolumeClaim",
                    "default": "my-bucket"
                  }
                },
                "required": [
                  "s3Url",
                  "bucketName"
                ]
              }
            ]
          },
          "persistence": {
            "$id": "#/properties/persistence",
            "type": "boolean",
            "title": "Persistence"
          },
          "volumeSize": {
            "$id": "#/properties/volumeSize",
            "type": "integer",
            "title": "Peristent Volume Size (in GB)",
            "default": 10,
            "minimum": 1
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#/properties/enabled",
            "#/properties/storage",
            "#/properties/persistence",
            "#/properties/volumeSize"
          ],
          "uiSchema": {
          },
          "metaData": {}
        }
      ]
  - name: Grafana Cloud
    variable: grafanaCloud
    category: logging
    logo: https://grafana.com/static/img/menu/grafana2.svg
    description: ""
    onePager: |-
      Install Promtail to ship logs to Grafana Cloud.
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#grafanaCloud",
        "type": "object",
        "title": "Grafana Cloud",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "clusterName": {
            "$id": "#/properties/clusterName",
            "type": "string",
            "title": "Cluster Name",
            "description": "A unique cluster identifier that is attached to labels shipped by this Prometheus. You can use this later on for querying."
          },
          "url": {
            "$id": "#/properties/url",
            "type": "string",
            "title": "URL",
            "description": "URL field on the Grafana Cloud dashboard"
          },
          "username": {
            "$id": "#/properties/username",
            "type": "string",
            "title": "User",
            "description": "User field on the Grafana Cloud dashboard"
          },
          "password": {
            "$id": "#/properties/password",
            "type": "string",
            "title": "Password / API Key",
            "description": "Password field on the Grafana Cloud dashboard"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#grafanaCloud"
          ],
          "uiSchema": {
          },
          "metaData": {}
        }
      ]
  - name: Event Exporter
    variable: eventExporter
    category: logging
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/opsgenie.png
    description: ""
    onePager: |-
      Install Kubernetes Event Exporter to log all Kubernetes events.
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#eventExporter",
        "type": "object",
        "title": "Event Exporter",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#eventExporter"
          ],
          "uiSchema": {
          },
          "metaData": {}
        }
      ]
  - name: Prometheus
    variable: prometheus
    category: metrics
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/prometheus.svg
    description: ""
    onePager: |-
      ### What do you get with Prometheus?
      - Infrastructure metrics and dashboards
      - Integration to application metrics
      - Default alerts and dashboards

      ### How to verify the deployment?

      ```
      $ kubectl get pods,svc --namespace infrastructure | grep 'prometheus\|grafana'

      NAME                                                   READY   STATUS    RESTARTS   AGE
      grafana-6987c9c5cf-gsr6x                               1/1     Running   0          66s
      prometheus-kube-state-metrics-c65b87574-qw56j          1/1     Running   0          65s
      prometheus-node-exporter-z8hgt                         1/1     Running   0          65s
      prometheus-pushgateway-7dc7cd5748-zzcc9                1/1     Running   0          65s
      prometheus-alertmanager-78b946d89-8djl8                1/2     Running   0          65s
      prometheus-server-b65c9b875-j62n8                      1/2     Running   0          65s
      service/grafana                               ClusterIP      10.43.64.217    <none>        80/TCP
      service/prometheus-alertmanager               ClusterIP      10.43.154.189   <none>        80/TCP
      service/prometheus-kube-state-metrics         ClusterIP      10.43.66.232    <none>        8080/TCP
      service/prometheus-server                     ClusterIP      10.43.133.254   <none>        80/TCP
      service/prometheus-node-exporter              ClusterIP      None            <none>        9100/TCP
      service/prometheus-pushgateway                ClusterIP      10.43.77.103    <none>        9091/TCP
      ```

      ### Browsing metrics with Grafana
      You can access the dashboards by forwarding the internal Grafana ClusterIP to your laptop with:
      ```
      kubectl port-forward svc/grafana --namespace infrastructure 8888:80
      ```

      and access the dashboard on [http://localhost:8888](http://localhost:8888).

      Grafana generates an `admin` user password, and puts it into a Kubernetes secret. Grab it with:

      ```
      kubectl get secret grafana --namespace infrastructure --template='{{ index .data "admin-password"}}' | base64 -d
      ```

      Make sure to not include the trailing new line character: `%`

    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#prometheus",
        "type": "object",
        "title": "Prometheus",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "genericAlerts": {
            "$id": "#/properties/genericAlerts",
            "type": "boolean",
            "title": "Include Alerts",
            "description": "Enable to include generic alerts on CPU / memory / disk usage"
          },
          "retentionDays": {
            "$id": "#/properties/retentionDays",
            "type": "integer",
            "title": "Retentian (in days)",
            "default": 14,
            "minimum": 1,
            "maximum": 365
          },
          "persistence": {
            "$id": "#/properties/persistence",
            "type": "boolean",
            "title": "Persistence"
          },
          "volumeSize": {
            "$id": "#/properties/volumeSize",
            "type": "integer",
            "title": "Peristent Volume Size (in GB)",
            "default": 10,
            "minimum": 1,
            "maximum": 100
          },
          "grafanaCloud": {
            "$id": "#/properties/grafanaCloud",
            "type": "object",
            "title": "Write to Grafana Cloud",
            "properties": {
              "enabled": {
                "$id": "#/properties/enabled",
                "type": "boolean",
                "title": "Enabled"
              },
              "clusterName": {
                "$id": "#/properties/clusterName",
                "type": "string",
                "title": "Cluster Name",
                "description": "A unique cluster identifier that is attached to labels shipped by this Prometheus. You can use this later on for querying."
              },
              "url": {
                "$id": "#/properties/url",
                "type": "string",
                "title": "Remote Write Endpoint",
                "description": "Remote Write Endpoint URL on the Grafana Cloud dashboard"
              },
              "username": {
                "$id": "#/properties/username",
                "type": "string",
                "title": "Username / Instance ID",
                "description": "Username / Instance ID on the Grafana Cloud dashboard"
              },
              "password": {
                "$id": "#/properties/password",
                "type": "string",
                "title": "Password / API Key",
                "description": "Password / API Key on the Grafana Cloud dashboard"
              }
            }
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#prometheus"
          ],
          "uiSchema": {
            "#/properties/retentionDays": {
              "ui:widget": "range"
            },
            "#/properties/volumeSize": {
              "ui:widget": "range"
            }
          },
          "metaData": {}
        }
      ]
  - name: Encrypted Secrets
    variable: sealedSecrets
    category: secrets
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/sealedSecrets.svg
    description: ""
    onePager: |-
      ### What do you get with Sealed Secrets?
      - A secret manager that allows a simple secret workflow for gitops repositories.
      - Uses asymmetric cryptography to encrypt secrets, just like HTTPS.
      ### How to verify the deployment?

      ```
      $ kubectl get pods --namespace infrastructure

      NAME                              READY   STATUS    RESTARTS   AGE
      sealed-secrets-7d7cc48f7f-q64sm   1/1     Running   0          14m
      ```

      Once the pod is running, secrets will be unsealed inside the cluster and made available for your applications.

      ### After verification

      In order to encrypt secrets, run the following steps:

      #### Install the `kubeseal` utility

      You will use this utility to encrypt secrets for your applications. It uses asymmetric crypto to encrypt secrets that only the controller can decrypt.

      Mac:
      ```
      brew install kubeseal
      ```

      Linux:
      ```
      wget https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.12.6/kubeseal-linux-amd64 -O kubeseal
      sudo install -m 755 kubeseal /usr/local/bin/kubeseal
      ```

      #### Important steps after installing Sealed Secrets

      Perform these steps if you install Sealed Secrets for the first time, and you don't have encrypted secrets in your gitops repo yet.

      - fetch the sealing key

      ```
      kubeseal --fetch-cert --controller-namespace=infrastructure > sealing-key.pub
      ```

      This key is used to encrypt your secrets. It is only used to encrypt the secrets, noone can decrypt the secrets with this key, so you can share it with anyone.

      It is recommended that you add this key as a "Sealing Public Key" to 1-Click Infra bellow, so all keys in the gitops repo will be encrypted.

      - backup the master key

      ```
      kubectl get secret -n infrastructure -l sealedsecrets.bitnami.com/sealed-secrets-key -o yaml > master.key
      ```

      Keep this key secret, as this is the only key that can decrypt the secrets.
      Use it only in case of a cluster restoration.

      **Steps after restoration**

      Perform these steps if you are restoring your cluster, and you have encrypted secrets in your gitops repo already.

      Locate your backed up master key and apply it on the cluster.

      ```
      kubectl apply -f master.key
      ```

      Then restart the Sealed Secrets to pick up the master key:

      ```
      kubectl -n infrastructure delete pod -l name=sealed-secrets-controller
      ```

      Now your cluster can decrypt all secrets from the gitops repo.

    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#encryptedSecrets",
        "type": "object",
        "title": "Encrypted Secrets",
        "description": "",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#encryptedSecrets"
          ],
          "uiSchema": {},
          "metaData": {
            "link": {
              "label": "Encrypted Secrets",
              "href": "https://gimlet-documentation-home-page-revamp.gimlet.io/docs/deployment-settings/secrets"
            }
          }
        }
      ]
  - name: ExternalSecrets
    variable: externalSecrets
    category: secrets
    logo: https://raw.githubusercontent.com/external-secrets/external-secrets/main/assets/eso-logo-medium.png
    description: ""
    onePager: |-
      The project extends the Kubernetes API by adding an ExternalSecrets object using Custom Resource Definition and a controller to implement the behavior of the object itself.

      An ExternalSecret declares how to fetch the secret data, while the controller converts all ExternalSecrets to Secrets. The conversion is completely transparent to Pods that can access Secrets normally.

      - `ExternalSecrets` are added in the cluster (e.g., kubectl apply -f external-secret-example.yml)
      - Controller fetches `ExternalSecrets` using the Kubernetes API
      - Controller uses `ExternalSecrets` to fetch secret data from external providers (e.g, AWS Secrets Manager)
      - Controller upserts `Secrets`
      - Pods can access `Secrets` normally
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "http://example.com/example.json",
        "type": "object",
        "title": "External Secrets",
        "description": "The root schema comprises the entire JSON document.",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#/properties/enabled"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: OAuth2Proxy
    variable: oauth2Proxy
    category: ingress
    logo: https://raw.githubusercontent.com/oauth2-proxy/oauth2-proxy/master/docs/static/img/logos/OAuth2_Proxy_icon.svg
    description: ""
    onePager: |-
      ### What do you get with OAuth2Proxy?
      - You can authenticate your internal services with Github
      - Use it instead of a VPN

      ### How to verify the deployment?

      ```
      kubectl get pods --namespace infrastructure
      ```
      ```
      NAME                                                   READY   STATUS    RESTARTS   AGE
      oauth2-proxy-56cc5665c5-t6472                          2/2     Running   2          18h
      ```

      ### Configuring the Github OAuth app

      Follow the [Github guide](https://docs.github.com/en/developers/apps/building-oauth-apps/creating-an-oauth-app).

      - Set `https://auth.<<your-nginx-domain>>` for "Homepage URL"
      - Set `https://auth.<<your-nginx-domain>>/oauth2/callback` for "Authorization callback URL"

      ### Add OAuth to your service
      To add authentication for your services, add the following annotations to your ingresses:
      ```diff
      apiVersion: extensions/v1beta1
      kind: Ingress
      metadata:
        name: my-app
        namespace: infrastructure
        annotations:
          kubernetes.io/ingress.class: 'nginx'
      +   nginx.ingress.kubernetes.io/auth-url: "https://auth.<<your-nginx-domain>>/oauth2/auth"
      +   nginx.ingress.kubernetes.io/auth-signin: "https://auth.<<your-nginx-domain>>/oauth2/start?rd=/redirect/$http_host$escaped_request_uri"
      spec:
        tls:
        - hosts:
          - my-app.<<your-nginx-domain>>
        rules:
          - host: my-app.<<your-nginx-domain>>
            http:
              paths:
                - backend:
                    serviceName: my-app
                    servicePort: 80
      ```

      ### Checking if you are logged in

      Visit [https://auth.<<your-nginx-domain>>/oauth2/userinfo](https://auth.<<your-nginx-domain>>/oauth2/userinfo)
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#oauth2Proxy",
        "type": "object",
        "title": "OAuth2Proxy",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "cookieSecret": {
            "$id": "#/properties/cookieSecret",
            "type": "string",
            "title": "Cookie Secret",
            "description": "A random seed string that is the base of cookie encryption. eg: the output of `openssl rand -hex 16`"
          },
          "org": {
            "$id": "#/properties/org",
            "type": "string",
            "title": "Github Organization",
            "description": "Github users member of this organization will be allowed to access your protected sites"
          },
          "user": {
            "$id": "#/properties/user",
            "type": "string",
            "title": "Github User",
            "description": "If you want to grant access per user basis, a comma separated list"
          },
          "clientID": {
            "$id": "#/properties/clientID",
            "type": "string",
            "title": "Github ClientID",
            "description": "ClientID of the Github OAuth application"
          },
          "clientSecret": {
            "$id": "#/properties/clientSecret",
            "type": "string",
            "title": "Github Client Secret",
            "description": "Client secret of the Github OAuth application"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#oauth2Proxy"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: Gimlet Agent
    variable: gimletAgent
    category: gimlet
    logo: https://gimlet.io/logo.svg
    description: ""
    onePager: |-

    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#gimletAgent",
        "type": "object",
        "title": "Gimlet Agent",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "environment": {
            "$id": "#/properties/environment",
            "type": "string",
            "title": "Environment",
            "description": "The logical name of the environment the agent is deployed to"
          },
          "dashboardAddress": {
            "$id": "#/properties/dashboardAddress",
            "type": "string",
            "title": "Gimlet Dashboard Address",
            "description": "The address where Gimlet Dashboard is running, eg.: https://gimlet.mycompany.com"
          },
          "agentKey": {
            "$id": "#/properties/agentKey",
            "type": "string",
            "title": "Agent Key",
            "description": "Agent Key to authenticate to Gimlet Dashboard"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#gimletAgent"
          ],
          "uiSchema": {},
          "metaData": {}
        }
      ]
  - name: Gimlet Image Builder
    variable: imageBuilder
    category: gimlet
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/buildPacks.svg
    description: ""
    onePager: "Image builder is a simple web server application that handles file uploads and builds images from it."

    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#imageBuilder",
        "type": "object",
        "title": "Gimlet Image Builder",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#imageBuilder"
          ],
          "uiSchema": {
          },
          "metaData": {}
        }
      ]
  - name: KEDA
    variable: keda
    category: autoscaling
    logo: https://keda.sh/img/logos/keda-horizontal-color.png
    description: ""
    onePager: "KEDA is an alternative solution for Prometheus Adapter, it gives you a simple, straightforward and efficient approach to autoscale your application."
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#keda",
        "type": "object",
        "title": "KEDA",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#keda"
          ],
          "uiSchema": {
          },
          "metaData": {}
        }
      ]
  - name: Containerized Registry
    variable: containerizedRegistry
    category: registry
    logo: https://d1q6f0aelx0por.cloudfront.net/product-logos/library-registry-logo.png
    description: ""
    onePager: "Containerized registry deployed in the same cluster where the image is deployed."
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#containerizedRegistry",
        "type": "object",
        "title": "Containerized Registry",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#containerizedRegistry"
          ],
          "uiSchema": {
          },
          "metaData": {}
        }
      ]
  - name: Custom Registry
    variable: customRegistry
    category: registry
    logo: https://d1q6f0aelx0por.cloudfront.net/product-logos/library-registry-logo.png
    description: ""
    onePager: "Custom Registry is an existing registry you want ot use in Gimlet"
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#customRegistry",
        "type": "object",
        "title": "Custom Registry",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "displayName": {
            "$id": "#/properties/displayName",
            "type": "string",
            "title": "Display Name"
          },
          "url": {
            "$id": "#/properties/url",
            "type": "string",
            "title": "URL",
            "description": "Host name of the registry, like `ghcr.io`"
          },
          "config": {
            "$id": "#/properties/config",
            "type": "object",
            "properties": {
              "login": {
                "$id": "#/properties/login",
                "type": "string",
                "title": "Login"
              },
              "encryptedDockerconfigjson": {
                "$id": "#/properties/encryptedDockerconfigjson",
                "type": "string",
                "title": "encryptedDockerconfigjson"
              }
            }
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#customRegistry"
          ],
          "uiSchema": {
            "#customRegistry": {
              "#/properties/config": {
                "ui:field": "ghcrRegistryWidget"
              }
            }
          },
          "metaData": {}
        }
      ]
  - name: Github Container Registry
    variable: ghcrRegistry
    category: registry
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/registry.svg
    description: ""
    onePager: "The GitHub Container registry allows you to host and manage your Docker container images in your personal or organisation account on GitHub."
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#ghcrRegistry",
        "type": "object",
        "title": "Github Container Registry",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "login": {
            "$id": "#/properties/login",
            "type": "string",
            "title": "Login"
          },
          "encryptedDockerconfigjson": {
            "$id": "#/properties/encryptedDockerconfigjson",
            "type": "string",
            "title": "encryptedDockerconfigjson"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#ghcrRegistry"
          ],
          "uiSchema": {
            "#ghcrRegistry": {
              "ui:field": "ghcrRegistryWidget"
            }
          },
          "metaData": {
            "link": {
              "label": "Github Container Registry",
              "href": "https://gimlet.io"
            }
          }
        }
      ]
  - name: Docker Hub
    variable: dockerhubRegistry
    category: registry
    logo: https://raw.githubusercontent.com/gimlet-io/gimlet-stack-reference/main/assets/registry.svg
    description: ""
    onePager: "Docker Hub is a container registry built for developers and open source contributors to find, use, and share their container images."
    schema: |-
      {
        "$schema": "http://json-schema.org/draft-07/schema",
        "$id": "#dockerhubRegistry",
        "type": "object",
        "title": "Docker Hub",
        "properties": {
          "enabled": {
            "$id": "#/properties/enabled",
            "type": "boolean",
            "title": "Enabled"
          },
          "login": {
            "$id": "#/properties/login",
            "type": "string",
            "title": "Login"
          },
          "encryptedDockerconfigjson": {
            "$id": "#/properties/encryptedDockerconfigjson",
            "type": "string",
            "title": "encryptedDockerconfigjson"
          }
        }
      }
    uiSchema: |-
      [
        {
          "schemaIDs": [
            "#dockerhubRegistry"
          ],
          "uiSchema": {
            "#dockerhubRegistry": {
              "ui:field": "dockerhubRegistryWidget"
            }
          },
          "metaData": {}
        }
      ]
changeLog: |
  - 🆕 Github Container Registry support
  - 🆕 Docker Hub Registry support
  - ❗ Docker Image Registry renamed to Built-in registry
message: |

  Hey 👋 Laszlo here, the founder of Gimlet.io

  Thank you for using Gimlet!

  Our goal is to help you

  - to get started with your Kubernetes stack
  - to navigate new versions
  - and to give you best practices

  Now that you generated Kubernetes resources from your stack, 
  you can check out how to manage it in the future

  👉 https://gimlet.io/docs/managing-infrastructure-components

  Onwards!
